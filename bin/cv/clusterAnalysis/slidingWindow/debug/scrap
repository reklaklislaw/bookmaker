
struct clusters* RunSlidingWindowClustering(struct corners *corners,
					    unsigned int window_width,
					    unsigned int window_height) {
  
  unsigned int i;
  unsigned int k;
  unsigned int m;
  unsigned int n;
  unsigned int p;
  unsigned int q;
  
  unsigned int num_assigned = 0;
  unsigned int ok;
  
  unsigned int L;
  unsigned int R;
  unsigned int T;
  unsigned int B;
  
  unsigned int *queue;
  unsigned int queue_count;
  queue = (unsigned int *) malloc (sizeof(unsigned int) * corners->num_corners);
  
  unsigned int exists;
  signed int join; 

  struct clusters *clusters = (struct clusters *) malloc(sizeof(struct clusters));
  clusters->cluster     = (unsigned int **) malloc(sizeof(unsigned int)*corners->num_corners);    
  clusters->cluster_size = (unsigned int *) malloc(sizeof(unsigned int)*corners->num_corners*5);    

  clusters->mx = corners->mx;
  clusters->my = corners->my;
  clusters->skew_angle = corners->skew_angle;
  clusters->window_height = window_height;
  clusters->window_width = window_width;
  clusters->num_clusters = 0;
  clusters->cluster_size[0] = 0;
  
  //iterate over all corners
  for (i=0;i<corners->num_corners;i++) {
    ok = 0;
    
    //then check against list of corners already in a cluster 
    for (k=0;k<num_assigned;k++) {
      if (corners->assigned[k] == corners->x_key[i]) {
        ok = 1;
        break;
      }
    }
    
    //if we didnt find a match we will make try to form a new cluster around it
      if (ok==0) {
        if ((corners->x[i] - window_width) < 0)
          L = 0;
        else
          L = corners->x[i] - window_width;

        if ((corners->y[i] - window_height) < 0)
          T = 0;
        else
          T = corners->y[i] - window_height;

        R = corners->x[i] + window_width;
        B = corners->y[i] + window_height;

        queue_count = 0;
    
        //check all corners against window
        for (m=0;m<corners->num_corners;m++) {        
          //printf("trying %hu\n",m);
          if (((corners->x[m] >= L) && (corners->x[m] <= R)) && 
              ((corners->y[m] >= T) && (corners->y[m] <= B))) {        
            //printf("\n\n%hu --\n\n",m);
            queue[queue_count] = m;
            queue_count++;
            corners->assigned[num_assigned] = m;
            num_assigned++;
          }
        }
      
        //if we found more than one corner, we check to see if they are contained
        //in an already existing cluster. if they are we add everything in the current
        // queue to that cluster. if not we start a new cluster.
        if (queue_count > 1 ) {
          join = -1;
          if (clusters->num_clusters > 0)
            for (n=0; n < queue_count; n++) {
              //printf("EVALUATING CORNER %hu...\n",queue[n]);
              for (p=1; p <= clusters->num_clusters; p++) {
                //printf("checking in cluster %hu...\n",p);
                for (q=0; q < clusters->cluster_size[p]; q++) {
                  //printf("Does corner |%hu| match cluster %hu %hu value |%hu|?\n", queue[n],p,q,clusters->cluster[p][q]);
                  if (queue[n] == clusters->cluster[p][q]) {
                    //printf("\nFound Match in corner %hu..joining to cluster %hu\n",queue[n],p);
                    join = p;
                    break;
                  }
                  if (join != -1)
                    break;
                }
                if (join != -1)
                  break;
              }
              if (join != -1)
                break;
            }

          //start a new cluster
          if (join == -1) {
            clusters->num_clusters++;
            join = clusters->num_clusters;
            //printf("\nStarting new cluster: %hu \n",join);
            clusters->cluster[join] = (unsigned int *) malloc(sizeof(unsigned int)*corners->num_corners);
	    clusters->cluster_size[join] = 0;
            for (n=0; n < queue_count; n++) {
              clusters->cluster[join][n] = queue[n];
              clusters->cluster_size[join]++;
              //if (join==1)
		//printf("%hu | Added corner %hu to cluster %hu TOTAL:%hu |%hu |\n",n,queue[n],join,clusters->cluster_size[join],clusters->cluster[join][n]);
            }
          } else {
            //add to an existing cluster
            for (n=0; n < queue_count; n++) {
              exists = 1;
              //for (q=0; q < clusters->cluster_size[join]; q++) 
              for (q=0; q < corners->num_corners; q++) {
                if (clusters->cluster[join][q]!='\0') {
                  //printf("checking cluster %hu corner %hu | value:%hu\n",join,q,clusters->cluster[join][q]);
                  if (queue[n] == clusters->cluster[join][q]) { 
                    exists = 0;
                    //printf("%hu exists in cluster %hu already\n",queue[n],join);
                    break;
                  }
                }
              }
              if (exists == 1) {
                clusters->cluster[join][clusters->cluster_size[join]] = queue[n];
                //if (join==1)
		//printf("Added corner %hu to cluster %hu TOTAL:%hu   |  %hu  | \n",queue[n],join,clusters->cluster_size[join],clusters->cluster[join][clusters->cluster_size[join]]);
                clusters->cluster_size[join]++;    
              }       
            }
          }       
        }  
      }   
      //ticks = clock();
  }
					 					 					 
  //time(&end);
  //printf("total cpu time:%0.5f  |  total time spent on clustering:%0.5f\n", (double) ticks/CLOCKS_PER_SEC, difftime(end,start));
  /*
  for (i=0;i<=clusters->num_clusters;i++) {
    if (clusters->cluster[i]!=NULL)
      for(q=0;q<numValues;q++) {
        if (clusters->cluster[i][q]!='\0')
          printf("cluster %hu num %hu\n",i,q);
    }
  }*/



  //printf("num corners %du\n", corners->num_corners);
 
  free((unsigned int *)queue);    
  
  AmalgamateClusters(clusters,
		     corners);    
  
  return CompositeDimensions(clusters,
			     corners);

}


void AmalgamateClusters(struct clusters *clusters,
			struct corners *corners) {


  //time_t start, end;
  //clock_t ticks;
  //time(&start);

  unsigned int p1;
  unsigned int q1;
  unsigned int z1;
  
  unsigned int x1;
  unsigned int y1;
  unsigned int r1;
  unsigned int b1;

  unsigned int p2;
  unsigned int q2;
  unsigned int z2;

  unsigned int x2;
  unsigned int y2;
  unsigned int r2;
  unsigned int b2;

  unsigned int minx = '\0';
  unsigned int miny = '\0';
  unsigned int maxx = '\0';
  unsigned int maxy = '\0';

  unsigned int exists;
  unsigned int counter;
  unsigned int *taken;
  unsigned int t_count;
  unsigned int ok;
  unsigned int n;
  unsigned int b;

  t_count = 0;
  taken = (unsigned int *) malloc (sizeof(unsigned int)*clusters->num_clusters);

  unsigned int window_width = clusters->window_width;
  unsigned int window_height = clusters->window_height;
  
  //loop 1... test against this cluster (primary), then injest secondary cluster if applicable
  for (p1=1; p1 <= clusters->num_clusters; p1++) {
    
    ok = 0;
    for (n=0;n<clusters->num_clusters;n++)
      if (p1 == taken[n]) {   
        ok = 1;
        break;
      } 
    
    if (ok == 0) {
      
      minx = '\0';
      miny = '\0';
      maxx = '\0';
      maxy = '\0';
      
      counter = 0;
      for(q1=0; q1 < corners->num_corners; q1++) {      
        if (clusters->cluster[p1][q1] != '\0' &&
	    clusters->cluster_size[p1] > q1) {
          if (minx == '\0' && miny == '\0' && maxx == '\0' && maxy == '\0') {
            minx = corners->x[clusters->cluster[p1][q1]];
            miny = corners->y[clusters->cluster[p1][q1]];
            maxx = corners->x[clusters->cluster[p1][q1]];
            maxy = corners->y[clusters->cluster[p1][q1]];
          } else {
	    //printf("p:%u q:%u  %u\n", p1, q1, clusters->cluster[p1][q1]);
            if (corners->x[clusters->cluster[p1][q1]] < minx)
              minx = corners->x[clusters->cluster[p1][q1]];
            if (corners->y[clusters->cluster[p1][q1]] < miny)
              miny = corners->y[clusters->cluster[p1][q1]];
            if (corners->x[clusters->cluster[p1][q1]] > maxx)
              maxx = corners->x[clusters->cluster[p1][q1]];
            if (corners->y[clusters->cluster[p1][q1]] > maxy)
              maxy = corners->y[clusters->cluster[p1][q1]];
          }
          counter++;
          if (counter == clusters->cluster_size[p1]) {
            break;
          }
        }
      }
      
      if (minx - window_width < 0)
        x1 = 0;
      else
        x1 = minx - window_width;
      
      if (miny - window_height < 0)
        y1 = 0;
      else
        y1 = miny - window_height;
      
      r1 = maxx + window_width;
      b1 = maxy + window_height;
      
      //loop 2...secondary cluster to be checked/injested
      for (p2=1; p2 <= clusters->num_clusters; p2++) {
        if (p2!=p1) {
          ok = 0;
          for (n=0;n<clusters->num_clusters;n++)
            if (p2 == taken[n]) { 
              ok = 1;
              break;
            } 
          
          if (ok==0) {        
            counter = 0;
            
            minx = '\0';
            miny = '\0';
            maxx = '\0';
            maxy = '\0';
          
            for(q2=0; q2 < corners->num_corners; q2++) {
              if (clusters->cluster[p2][q2] != '\0' &&
		  clusters->cluster_size[p2] > q2) {
                if (minx == '\0' && miny == '\0' && maxx == '\0' && maxy == '\0') {
                  minx = corners->x[clusters->cluster[p2][q2]];
                  miny = corners->y[clusters->cluster[p2][q2]];
                  maxx = corners->x[clusters->cluster[p2][q2]];
                  maxy = corners->y[clusters->cluster[p2][q2]];
                } else {
                  if (corners->x[clusters->cluster[p2][q2]] < minx)
                    minx = corners->x[clusters->cluster[p2][q2]];
                  if (corners->y[clusters->cluster[p2][q2]] < miny)
                    miny = corners->y[clusters->cluster[p2][q2]];
                  if (corners->x[clusters->cluster[p2][q2]] > maxx)
                    maxx = corners->x[clusters->cluster[p2][q2]];
                  if (corners->y[clusters->cluster[p2][q2]] > maxy)
                    maxy = corners->y[clusters->cluster[p2][q2]];
                }
                counter++;
                if (counter == clusters->cluster_size[p2]) {
                  break;
                }
              }
            }
            
            if (minx - window_width < 0)
              x2 = 0;
            else
              x2 = minx - window_width;
            
            if (miny - window_height < 0)
              y2 = 0;
            else
              y2 = miny - window_height;
            
            r2 = maxx + window_width;
            b2 = maxy + window_height; 
                
            //fprintf(log,"%hu vs %hu\n",p1,p2);        
            //if the two clusters touch/overlap, lets merge secondary into primary, then start the check over 
            if ( (((x1 >= x2)&&(x1 <= r2)) && (((y1 >= y2)&&(y1 <= b2)) || ((y1 <= y2)&&(b1 >= b2)))) ||
                 (((x1 <= x2)&&(r1 >= x2)) && (((y1 >= y2)&&(y1 <= b2)) || ((b1 >= y2)&&(b1 <= b2)) || ((y1 < y2)&&(b1 > b2)))) ) 
              {                
                
                for (z2=0;z2<corners->num_corners;z2++)
                  if (clusters->cluster[p2][z2] != '\0')  {
                    exists = 1;
                    for (z1=0; z1<corners->num_corners;z1++)
                      if (clusters->cluster[p1][z1] != '\0')  {
                        if (clusters->cluster[p2][z2] == clusters->cluster[p1][z1]) {
                          exists = 0;
                          break;
                        }
                      }
                    if (exists==1) {
                      clusters->cluster[p1][clusters->cluster_size[p1]] = clusters->cluster[p2][z2];
                      clusters->cluster_size[p1]++;
                      //fprintf(log,"JOINING %hu to %hu\n",p2,p1);
                    }    
                  }
                
                //we must update the dimensions of primary cluster
                counter = 0;
                for(b=0; b < corners->num_corners; b++) {      
                  if (clusters->cluster[p1][b] != '\0') {
                    if (minx == '\0' && miny == '\0' && maxx == '\0' && maxy == '\0') {
                      minx = corners->x[clusters->cluster[p1][b]];
                      miny = corners->y[clusters->cluster[p1][b]];
                      maxx = corners->x[clusters->cluster[p1][b]];
                      maxy = corners->y[clusters->cluster[p1][b]];
                    } else {
                      if (corners->x[clusters->cluster[p1][b]] < minx)
                        minx = corners->x[clusters->cluster[p1][b]];
                      if (corners->y[clusters->cluster[p1][b]] < miny)
                        miny = corners->y[clusters->cluster[p1][b]];
                      if (corners->x[clusters->cluster[p1][b]] > maxx)
                        maxx = corners->x[clusters->cluster[p1][b]];
                      if (corners->y[clusters->cluster[p1][b]] > maxy)
                        maxy = corners->y[clusters->cluster[p1][b]];
                    }
                    counter++;
                    if (counter == clusters->cluster_size[p1]) {
                      break;
                    }
                  }
                }
                
                if (minx - window_width < 0)
                  x1 = 0;
                else
                  x1 = minx - window_width;
                
                if (miny - window_height < 0)
                  y1 = 0;
                else
                  y1 = miny - window_height;
                
                r1 = maxx + window_width;
                b1 = maxy + window_height;
                                
                //blacklist/unset secondary cluster, then reset loop 2 position            
                clusters->cluster[p2] = '\0';
                free((unsigned int *)clusters->cluster[p2]);
                taken[t_count] = p2;
                t_count++;
                p2 = 0;
                
              } 
          }
        }
      } 
    }
    //ticks = clock();
  }
  
  //time(&end);
  //printf("total cpu time:%0.5f  |  total time spent on amalgamation:%0.5f\n", (double) ticks/CLOCKS_PER_SEC, difftime(end,start));
  
  free(taken);
}


struct clusters* CompositeDimensions(struct clusters *clusters,
				     struct corners *corners) {

  //time_t start, end;
  //clock_t ticks;
  //time(&start);

  //FILE *clusterdims;  
  //clusterdims = fopen(out_file,"w");

  unsigned int mx = clusters->mx;
  unsigned int my = clusters->my;

  unsigned int **l;
  unsigned int **r;
  unsigned int **t;
  unsigned int **b;

  clusters->dimensions = (struct dimensions *) malloc(sizeof(struct dimensions)*clusters->num_clusters);

  l = (unsigned int **) malloc(sizeof(unsigned int)*clusters->num_clusters*2);
  r = (unsigned int **) malloc(sizeof(unsigned int)*clusters->num_clusters*2);
  t = (unsigned int **) malloc(sizeof(unsigned int)*clusters->num_clusters*2);
  b = (unsigned int **) malloc(sizeof(unsigned int)*clusters->num_clusters*2);

  float deskew_angle;
  
  unsigned int i;
  unsigned int k;
  unsigned int j = 0;
  for (i=1; i<=clusters->num_clusters;i++) {
    if (clusters->cluster[i] != '\0') {
      //printf ("CLUSTER%hu\n",i);
      l[i] = (unsigned int *) malloc(sizeof(unsigned int));
      r[i] = (unsigned int *) malloc(sizeof(unsigned int));
      t[i] = (unsigned int *) malloc(sizeof(unsigned int));
      b[i] = (unsigned int *) malloc(sizeof(unsigned int));
      l[i][0]='\0';
      r[i][0]='\0';
      t[i][0]='\0';
      b[i][0]='\0';
      //printf("Cluster %hu count %hu",i,clusters->cluster_size[i]);
      for (k=0;k<clusters->cluster_size[i];k++) {
        
        //fprintf(log,"cluster%hu num%hu -> %hu: X%hu Y:%hu \n",i,k,clusters->cluster[i][k],corners->x [ clusters->cluster[i][k] ],corners->y [ clusters->cluster[i][k] ]);
        //printf("cluster%hu num%hu -> %hu:%hu\n",i,k,clusters->cluster[i][k],corners->x [ clusters->cluster[i][k] ]);
        
        if (l[i][0]=='\0' && r[i][0]=='\0' && t[i][0]=='\0' && b[i][0]=='\0') {
          //printf("INIT MIN @ %hu %hu\n",i,k);
          l[i][0] = corners->x [ clusters->cluster[i][k] ];
          r[i][0] = corners->x [ clusters->cluster[i][k] ];
          t[i][0] = corners->y [ clusters->cluster[i][k] ];
          b[i][0] = corners->y [ clusters->cluster[i][k] ];            
          
          //FIXME
          //compiling with -O3 results in weird behavior here, 
          //where unless I uncomment-out this printf line I get wacky values every once in a while...
          //printf("INIT MIN @ C%u %u l:%u r:%u t:%u b:%u\n",i,k,l[i][0],r[i][0],t[i][0],b[i][0]);
        } else {
          if (corners->x [ clusters->cluster[i][k] ] < l[i][0])
            l[i][0] = corners->x [ clusters->cluster[i][k] ];
          if (corners->x [ clusters->cluster[i][k] ] > r[i][0])
            r[i][0] = corners->x [ clusters->cluster[i][k] ];
          if (corners->y [ clusters->cluster[i][k] ] < t[i][0])
            t[i][0] = corners->y [ clusters->cluster[i][k] ];
          if (corners->y [ clusters->cluster[i][k] ] > b[i][0])
            b[i][0] = corners->y [ clusters->cluster[i][k] ];     
        }
      }

#if !DESKEW_OUT      
      clusters->dimensions[j].l = l[i][0];
      clusters->dimensions[j].t = t[i][0];
      clusters->dimensions[j].r = r[i][0];
      clusters->dimensions[j].b = b[i][0];
      clusters->dimensions[j].size = clusters->cluster_size[i];
#endif

#if DESKEW_OUT
      deskew_angle = 0 - clusters->skew_angle;
     
      clusters->dimensions[j].l = ((( (int)l[i][0] - (int)mx) * cosf(DEG2RAD(deskew_angle))) - 
				   (( (int)t[i][0] - (int)my) * sinf(DEG2RAD(deskew_angle))) + (int)mx);
      
      clusters->dimensions[j].t = ((( (int)l[i][0] - (int)mx) * sinf(DEG2RAD(deskew_angle))) + 
				   (( (int)t[i][0] - (int)my) * cosf(DEG2RAD(deskew_angle))) + (int)my);
      
      clusters->dimensions[j].r = ((( (int)r[i][0] - (int)mx) * cosf(DEG2RAD(deskew_angle))) - 
				   (( (int)b[i][0] - (int)my) * sinf(DEG2RAD(deskew_angle)) ) + (int)mx);
      
      clusters->dimensions[j].b = ((( (int)r[i][0] - (int)mx) * sinf(DEG2RAD(deskew_angle))) + 
				   (( (int)b[i][0] - (int)my) * cosf(DEG2RAD(deskew_angle)) ) + (int)my);

      clusters->dimensions[j].size = clusters->cluster_size[i];
#endif

      j++;
    } 
    
  }


  /*  
  l = 0;
  free(l);
  t = 0;
  free(t);
  r = 0;
  free(r);
  b = 0;
  free(b);
  */
  
  clusters->num_clusters = j-1;
  return clusters;
  
}
