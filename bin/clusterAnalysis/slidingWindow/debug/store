





  




/*
    set = 0;
    //printf("%u---num assigned %u\n", c1, num_assigned);
    //then check against list of corners already in a cluster 
    for (ac=0; ac < num_assigned; ac++) {
      if (corners->assigned[ac] == c1) {
	//printf("corner %u is already assigned...\n",c1);
        set = 1;//already in cluster
        break;
      }
    }
    
    //if we didnt find a match we will make try to form a new cluster around it
    if (set==0) {
      //printf("trying to form cluster around corner %u \n", c1);
      InitWindow(window, corners, clusters, c1);
      queue_count = 0;
      //check all corners against window
      for (c2=0; c2 < corners->num_corners; c2++) {   
	if (c2 != c1) {
	  //printf("checking corner %u\n",c2);
	  if (CornerIsContainedByWindow(corners->x[c2], corners->y[c2], window)) {
	    //printf("adding corner %u to the queue\n", c2);
	    queue[queue_count] = c2;
	    queue_count++;
	  }
	}
      }
      
      
      //if we found more than one corner, we check to see if they are contained
      //in an already existing cluster. if they are we add everything in the current
      // queue to that cluster. if not we start a new cluster.
      if (queue_count > 1 ) {	  
	join = SearchClustersForQueuedCorners(clusters, queue, queue_count);
	//start a new cluster
	if (join == -1) {
	  StartNewCluster(corners, clusters, queue, queue_count, &num_assigned);
	}
	else {
	  //printf("Will try adding %u corners to cluster %u...\n\n", queue_count, join);
	  //AddToCluster(corners, clusters, queue, queue_count, join, &num_assigned);
	}  
      }   
    }
*/
