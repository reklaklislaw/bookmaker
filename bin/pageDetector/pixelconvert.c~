#ifndef _PIXELCONVERT_C_
#define _PIXELCONVERT_C_

#include "pixelconvert.h"

PIX* JpegScale(char *in_file, 
	       int rot_dir,
	       int scale_factor,
	       char *scaled_out_file) {

  FILE *in_stream, *out_stream;
  PIX *pix_scaled, *pix_scaled_rotated;

  in_stream = fopenReadStream(in_file);
  if (in_stream==NULL)
    {
      printf("Failed to open in_file\n");
      exit(1);
    }
  pix_scaled = pixReadStreamJpeg(in_stream, 0, scale_factor, NULL, 0);
  if (pix_scaled==NULL)
    {
      printf("Failed to scale\n");
      exit(1);
    }
  if (rot_dir == 1 || rot_dir==-1)
    pix_scaled_rotated = pixRotate90(pix_scaled, rot_dir);
  else if (rot_dir == 0)
    pix_scaled_rotated = pix_scaled;
  else {
    printf("Invalid rot_dir [-1,0,1]\n");
    exit(1);
  }
    
  if (pix_scaled_rotated==NULL)
    {
      printf("Failed to rotate\n");
      exit(1);
    }
  
  if (scaled_out_file!=NULL) 
    {
      out_stream = fopen(scaled_out_file, "w");
      if (out_stream) {
	pixWriteStreamJpeg(out_stream, pix_scaled_rotated, 30, 0);
	fclose(out_stream);
      } else
	printf("failed to open out_stream!\n");
    }

  return pix_scaled_rotated;
}



//CREDIT RAJ KUMAR http://github.com/rajbot/autocrop
PIX* ConvertToGray(PIX *pix, 
		   l_int32 *graychannel) {

    PIX *pix_gray;
    l_int32 maxchannel;
    l_int32 use_single_channel_for_gray = 0;

    NUMA *hist_r, *hist_g, *hist_b;
    l_int32 ret = pixGetColorHistogram(pix, 1, &hist_r, &hist_g, &hist_b);
    assert(0 == ret);
    
    l_float32 maxval;
    l_int32   maxloc[3];
    
    ret = numaGetMax(hist_r, &maxval, &maxloc[0]);
    assert(0 == ret);
    
    printf("red peak at %d with val %f\n", maxloc[0], maxval);
    
    ret = numaGetMax(hist_g, &maxval, &maxloc[1]);
    assert(0 == ret);
    printf("green peak at %d with val %f\n", maxloc[1], maxval);
    
    ret = numaGetMax(hist_b, &maxval, &maxloc[2]);
    assert(0 == ret);
    printf("blue peak at %d with val %f\n", maxloc[2], maxval);
    
    unsigned int i;
    l_int32 max=0, secondmax=0;
    for (i=0; i<3; i++) {
        if (maxloc[i] > max) {
            max = maxloc[i];
            maxchannel = i;
        } else if (maxloc[i] > secondmax) {
            secondmax = maxloc[i];
        }
    }
    printf("max = %d, secondmax=%d\n", max, secondmax);
    if (max > (secondmax*2)) {
        printf("grayMode: SINGLE-channel, channel=%d\n", maxchannel);
        use_single_channel_for_gray = 1;
    } else {
        printf("grayMode: three-channel\n");    
    }

    if (use_single_channel_for_gray) {
        pix_gray = pixConvertRGBToGray (pix, (0==maxchannel), (1==maxchannel), (2==maxchannel));
        *graychannel = maxchannel;
    } else {
        pix_gray = pixConvertRGBToGray (pix, 0.30, 0.60, 0.10);
        *graychannel = kGrayModeThreeChannel;
    }
    
    return pix_gray;
}

#endif
